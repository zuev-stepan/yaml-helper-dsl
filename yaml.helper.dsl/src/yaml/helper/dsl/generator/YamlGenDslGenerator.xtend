/*
 * generated by Xtext 2.22.0
 */
package yaml.helper.dsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import yaml.helper.dsl.yamlGenDsl.Import
import yaml.helper.dsl.yamlGenDsl.Field
import yaml.helper.dsl.yamlGenDsl.Body
import yaml.helper.dsl.yamlGenDsl.Extend
import yaml.helper.dsl.yamlGenDsl.AnyField
import yaml.helper.dsl.yamlGenDsl.NestedField
import yaml.helper.dsl.yamlGenDsl.NestedFields
import yaml.helper.dsl.yamlGenDsl.StringProperty
import yaml.helper.dsl.yamlGenDsl.ValueProperty
import yaml.helper.dsl.yamlGenDsl.ValidatorProperty
import yaml.helper.dsl.yamlGenDsl.Value
import yaml.helper.dsl.yamlGenDsl.StringValue
import yaml.helper.dsl.yamlGenDsl.BooleanValue
import yaml.helper.dsl.yamlGenDsl.LiteralValue
import yaml.helper.dsl.yamlGenDsl.ListValue
import yaml.helper.dsl.yamlGenDsl.Validators
import yaml.helper.dsl.yamlGenDsl.SimpleValidator
import yaml.helper.dsl.yamlGenDsl.RegexValidator
import yaml.helper.dsl.yamlGenDsl.ListValidator

import com.google.common.base.Charsets
import com.google.common.io.Resources
import yaml.helper.dsl.yamlGenDsl.TrueBooleanValue

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class YamlGenDslGenerator extends AbstractGenerator {
	private def fix_path(String path) {
		var res = path.substring(0, path.length - ".yamlgen".length)
		res = res.replace('dot', 'ddot')
		res = res.replace('.', 'dot')
		return "yamlgen_" + res
	}
	
	private def python_bool(boolean value) {
		return value ? "True" : "False"
	}
	
	private def python_string(String value) {
		var res = value.replace("\\", "\\\\")
		res = res.replace("\b", "\\b")
		res = res.replace("\t", "\\t")
		res = res.replace("\n", "\\n")
		res = res.replace("\f", "\\f")
		res = res.replace("\r", "\\r")
		res = res.replace("\"", "\\\"")
		res = res.replace("\'", "\\'")
		
		return '"' + res + '"'
	}
	
	private def python_help_string(String help) {
		return help.substring(1, help.length - 1).python_string
	}
	
	private def python_value(Value value) {
		if (value instanceof StringValue) {
			return (value as StringValue).value.python_string
		}
		else if (value instanceof BooleanValue) {
			return (value instanceof TrueBooleanValue).python_bool
		}
		else if (value instanceof LiteralValue) {
			return (value as LiteralValue).value
		}
		else {
			var res = "["
			for (nestedValue : (value as ListValue).values) {
				res+=nestedValue.python_value + ","
			}
			return res + "]"
		}
	}
	
	private def field_create_start(AnyField field) {
		if (field.superField !== null)
			return "extend_field(" + field.superField.name + ", "
		else
			return "new_field("
	}
	
	private def field_create(Field field) {
		return field_create_start(field) + field.root.python_bool + ", True)"
	}
	
	private def field_create(NestedField nestedField) {
		return field_create_start(nestedField) 
		       + nestedField.mandatory.python_bool + ", " 
		       + nestedField.^default.python_bool + ")"
	}
	
	private def fields_create(NestedFields nestedFields) {
		return field_create_start(nestedFields) + "False, False)"
	}

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var filePath = resource.URI.segments.subList(3, resource.URI.segments.size).join('/')
		var file = filePath.fix_path + ".py"
		fsa.generateFile(file, '''
			from field import new_field, extend_field, wrap
			«FOR importStatement : resource.allContents.filter(Import).toIterable»
				«"from " + importStatement.importURI.fix_path.replace('/', '.') + " import *"»
			«ENDFOR»

			«FOR field : resource.allContents.filter(Field).toIterable»
				«field.compile»

			«ENDFOR»
		''')
		
		fsa.generateFile("actions.py", Resources.toString(Main.getResource("impl/actions.py"), Charsets.UTF_8))
		fsa.generateFile("dialogue.py", Resources.toString(Main.getResource("impl/dialogue.py"), Charsets.UTF_8))
		fsa.generateFile("field.py", Resources.toString(Main.getResource("impl/field.py"), Charsets.UTF_8))
		fsa.generateFile("main.py", Resources.toString(Main.getResource("impl/main.py"), Charsets.UTF_8))
		fsa.generateFile("messages.py", Resources.toString(Main.getResource("impl/messages.py"), Charsets.UTF_8))
		fsa.generateFile("validators.py", Resources.toString(Main.getResource("impl/validators.py"), Charsets.UTF_8))
		fsa.generateFile("build.sh", Resources.toString(Main.getResource("impl/build.sh"), Charsets.UTF_8))
	}
	
	
	
	private def compile(Field field) '''
		«field.name» = wrap(
			«field.field_create»
			«FOR help : field.help»
				.add_help(«help.python_help_string»)
			«ENDFOR»
			«field.body.compile»
		)
		«IF field.root»
		root = «field.name»
		«ENDIF»
	'''
	
	private def compile(Extend extend) '''
		.extend(«extend.parentSubfieldName.python_string»)
			«extend.body.compile»
		.end_extend()
	'''
	
	private def compile(NestedField nestedField) '''
		.add_field(
			«nestedField.field_create»
			«FOR help : nestedField.help»
				.add_help(«help.python_help_string»)
			«ENDFOR»
			«nestedField.body.compile»
		)
	'''
	
	private def compile(NestedFields nestedFields) '''
		.add_field_generator(
			«nestedFields.fields_create»
			«FOR help : nestedFields.help»
				.add_help(«help.python_help_string»)
			«ENDFOR»
			«nestedFields.body.compile»
		)
	'''
	
	
	private def compile(StringProperty stringProperty) '''
		.set_property(«stringProperty.key.python_string», «stringProperty.value.python_string»)
	'''
	
	private def compile(ValueProperty valueProperty) '''
		.set_property(«valueProperty.key.python_string», «valueProperty.value.python_value»)
	'''
	
	private def compile(Validators validators) '''
		«FOR t : validators.values.filter(SimpleValidator)»
		.add_validator(«t.value.python_string»)
		«ENDFOR»
		«FOR t : validators.values.filter(RegexValidator)»
		.add_regex_validator(«t.value.python_string»)
		«ENDFOR»
		«FOR t : validators.values.filter(ListValidator)»
		.add_list_validator(«t.value.equals("list+").python_bool»)
		«IF t.elementValidators !== null»
		«t.elementValidators.compile»
		«ENDIF»
		.end_list_validator()
		«ENDFOR»
	'''
	
	private def compile(ValidatorProperty validatorProperty) '''
		«IF validatorProperty.help !== null»
		.set_property("validator-description", «validatorProperty.help.python_string»)
		«ENDIF»
		«validatorProperty.value.compile»
	'''
	
	private def compile(Body body) '''
		«FOR t : body.elements.filter(StringProperty)»
		«t.compile»
		«ENDFOR»
		«FOR t : body.elements.filter(ValueProperty)»
		«t.compile»
		«ENDFOR»
		«FOR t : body.elements.filter(ValidatorProperty)»
		«t.compile»
		«ENDFOR»
		«FOR t : body.elements.filter(Extend)»
		«t.compile»
		«ENDFOR»
		«FOR t : body.elements.filter(NestedField)»
		«t.compile»
		«ENDFOR»
		«FOR t : body.elements.filter(NestedFields)»
		«t.compile»
		«ENDFOR»
	'''	
}
