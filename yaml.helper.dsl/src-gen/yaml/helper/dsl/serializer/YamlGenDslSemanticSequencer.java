/*
 * generated by Xtext 2.22.0
 */
package yaml.helper.dsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import yaml.helper.dsl.services.YamlGenDslGrammarAccess;
import yaml.helper.dsl.yamlGenDsl.Body;
import yaml.helper.dsl.yamlGenDsl.Extend;
import yaml.helper.dsl.yamlGenDsl.Field;
import yaml.helper.dsl.yamlGenDsl.Import;
import yaml.helper.dsl.yamlGenDsl.NestedField;
import yaml.helper.dsl.yamlGenDsl.NestedFields;
import yaml.helper.dsl.yamlGenDsl.Source;
import yaml.helper.dsl.yamlGenDsl.StringProperty;
import yaml.helper.dsl.yamlGenDsl.TypeProperty;
import yaml.helper.dsl.yamlGenDsl.Values;
import yaml.helper.dsl.yamlGenDsl.ValuesProperty;
import yaml.helper.dsl.yamlGenDsl.YamlGenDslPackage;

@SuppressWarnings("all")
public class YamlGenDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private YamlGenDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == YamlGenDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case YamlGenDslPackage.BODY:
				sequence_Body(context, (Body) semanticObject); 
				return; 
			case YamlGenDslPackage.EXTEND:
				sequence_Extend(context, (Extend) semanticObject); 
				return; 
			case YamlGenDslPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case YamlGenDslPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case YamlGenDslPackage.NESTED_FIELD:
				sequence_NestedField(context, (NestedField) semanticObject); 
				return; 
			case YamlGenDslPackage.NESTED_FIELDS:
				sequence_NestedFields(context, (NestedFields) semanticObject); 
				return; 
			case YamlGenDslPackage.SOURCE:
				sequence_Source(context, (Source) semanticObject); 
				return; 
			case YamlGenDslPackage.STRING_PROPERTY:
				sequence_StringProperty(context, (StringProperty) semanticObject); 
				return; 
			case YamlGenDslPackage.TYPE_PROPERTY:
				sequence_TypeProperty(context, (TypeProperty) semanticObject); 
				return; 
			case YamlGenDslPackage.VALUES:
				sequence_Values(context, (Values) semanticObject); 
				return; 
			case YamlGenDslPackage.VALUES_PROPERTY:
				sequence_ValuesProperty(context, (ValuesProperty) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Body returns Body
	 *
	 * Constraint:
	 *     elements+=BodyElement*
	 */
	protected void sequence_Body(ISerializationContext context, Body semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BodyElement returns Extend
	 *     Extend returns Extend
	 *
	 * Constraint:
	 *     (parentSubfieldName=STRING body=Body)
	 */
	protected void sequence_Extend(ISerializationContext context, Extend semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YamlGenDslPackage.Literals.EXTEND__PARENT_SUBFIELD_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YamlGenDslPackage.Literals.EXTEND__PARENT_SUBFIELD_NAME));
			if (transientValues.isValueTransient(semanticObject, YamlGenDslPackage.Literals.EXTEND__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YamlGenDslPackage.Literals.EXTEND__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExtendAccess().getParentSubfieldNameSTRINGTerminalRuleCall_1_0(), semanticObject.getParentSubfieldName());
		feeder.accept(grammarAccess.getExtendAccess().getBodyBodyParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SourceElement returns Field
	 *     AnyField returns Field
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (help+=HELP_STRING* root?='root'? name=ID superField=[Field|ID]? body=Body)
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SourceElement returns Import
	 *     Import returns Import
	 *
	 * Constraint:
	 *     path=STRING
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YamlGenDslPackage.Literals.IMPORT__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YamlGenDslPackage.Literals.IMPORT__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getPathSTRINGTerminalRuleCall_1_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AnyField returns NestedField
	 *     BodyElement returns NestedField
	 *     AnyNestedField returns NestedField
	 *     NestedField returns NestedField
	 *
	 * Constraint:
	 *     (help+=HELP_STRING* mandatory?='mandatory'? default?='default'? superField=[Field|ID]? body=Body)
	 */
	protected void sequence_NestedField(ISerializationContext context, NestedField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnyField returns NestedFields
	 *     BodyElement returns NestedFields
	 *     AnyNestedField returns NestedFields
	 *     NestedFields returns NestedFields
	 *
	 * Constraint:
	 *     (help+=HELP_STRING* superField=[Field|ID]? body=Body)
	 */
	protected void sequence_NestedFields(ISerializationContext context, NestedFields semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Source returns Source
	 *
	 * Constraint:
	 *     entries+=SourceElement+
	 */
	protected void sequence_Source(ISerializationContext context, Source semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BodyElement returns StringProperty
	 *     Property returns StringProperty
	 *     StringProperty returns StringProperty
	 *
	 * Constraint:
	 *     ((key='key' | key='name' | key='hint') value=STRING)
	 */
	protected void sequence_StringProperty(ISerializationContext context, StringProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BodyElement returns TypeProperty
	 *     Property returns TypeProperty
	 *     TypeProperty returns TypeProperty
	 *
	 * Constraint:
	 *     (
	 *         key='type' 
	 *         (
	 *             value='int' | 
	 *             value='float' | 
	 *             value='string' | 
	 *             value='list' | 
	 *             value='any' | 
	 *             value=STRING
	 *         ) 
	 *         help=STRING?
	 *     )
	 */
	protected void sequence_TypeProperty(ISerializationContext context, TypeProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BodyElement returns ValuesProperty
	 *     Property returns ValuesProperty
	 *     ValuesProperty returns ValuesProperty
	 *
	 * Constraint:
	 *     ((key='default' | key='values') value=Values)
	 */
	protected void sequence_ValuesProperty(ISerializationContext context, ValuesProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Values returns Values
	 *
	 * Constraint:
	 *     (values+=Values+ | string=STRING)
	 */
	protected void sequence_Values(ISerializationContext context, Values semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
